<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structured Reasoning Analyzer</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  
  <!-- Fonts matching index.html -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Google Sans', 'Noto Sans', sans-serif;
      background: #f8f9fa;
      color: #333;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    
    /* Header styling matching index.html */
    .hero {
      background: white;
      border-bottom: 1px solid #e9ecef;
      margin-bottom: 2rem;
    }
    
    .hero-body {
      padding: 2rem 0;
      text-align: center;
    }
    
    h1 {
      font-family: 'Castoro', serif;
      font-size: 2.5rem;
      font-weight: 300;
      color: #2c3e50;
      margin-bottom: 1rem;
    }
    
    h2, h3 {
      font-family: 'Castoro', serif;
      color: #2c3e50;
      margin-bottom: 1rem;
    }
    
    h2 { font-size: 1.8rem; }
    h3 { font-size: 1.4rem; }
    
    /* Card styling */
    .card {
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Button styling matching index.html academic style */
    .button {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      background: white;
      border: 2px solid #2c3e50;
      color: #2c3e50;
      text-decoration: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      margin: 0.25rem;
    }
    
    .button:hover {
      background: #2c3e50;
      color: white;
      transform: translateY(-1px);
    }
    
    .button.primary {
      background: #2c3e50;
      color: white;
    }
    
    .button.primary:hover {
      background: #34495e;
    }
    
    .button.success { border-color: #27ae60; color: #27ae60; }
    .button.success:hover { background: #27ae60; color: white; }
    
    .button.warning { border-color: #f39c12; color: #f39c12; }
    .button.warning:hover { background: #f39c12; color: white; }
    
    .button.info { border-color: #3498db; color: #3498db; }
    .button.info:hover { background: #3498db; color: white; }
    
    .button.danger { border-color: #e74c3c; color: #e74c3c; }
    .button.danger:hover { background: #e74c3c; color: white; }
    
    /* Split view layout */
    .split-view {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      position: relative;
    }
    
    .split-view::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      background: #e9ecef;
      margin-left: -0.5px;
    }
    
    /* Step boxes */
    .step-box {
      border: 1px solid #e9ecef;
      padding: 1rem;
      margin: 0.75rem 0;
      border-radius: 6px;
      background: white;
      font-size: 0.95rem;
    }
    
    .step-box strong {
      color: #2c3e50;
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Status indicators */
    .correct {
      border-left: 4px solid #27ae60;
      background: #f8fff9;
    }
    
    .incorrect {
      border-left: 4px solid #e74c3c;
      background: #fef9f9;
    }
    
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding: 0.5rem 0.75rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .status-indicator.correct {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status-indicator.incorrect {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .status-indicator::before {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.25rem;
    }
    
    .status-indicator.correct::before {
      background: #28a745;
    }
    
    .status-indicator.incorrect::before {
      background: #dc3545;
    }
    
    /* Progress bar */
    .progress-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    
    .progress-bar {
      flex: 1;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .progress-bar-fill {
      height: 100%;
      background: #2c3e50;
      transition: width 0.3s ease;
    }
    
    .progress-text {
      font-size: 0.9rem;
      color: #666;
      min-width: 60px;
      text-align: center;
    }
    
    /* Form elements */
    select, input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      font-size: 0.9rem;
      background: white;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #2c3e50;
      box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.1);
    }
    
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #2c3e50;
      font-size: 0.9rem;
    }
    
    /* Grid layouts */
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 1rem;
    }
    
    .grid-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    /* Loading animation */
    .loading {
      position: relative;
      padding: 2rem;
      text-align: center;
      color: #666;
    }
    
    .loading:after {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #e9ecef;
      border-radius: 50%;
      border-top-color: #2c3e50;
      animation: spin 1s linear infinite;
      margin-left: 0.5rem;
      vertical-align: middle;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Alert messages */
    .alert {
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      border-left: 4px solid;
    }
    
    .alert.error {
      background: #fef2f2;
      border-color: #e74c3c;
      color: #c53030;
    }
    
    .alert.warning {
      background: #fffbeb;
      border-color: #f39c12;
      color: #d69e2e;
    }
    
    .alert.info {
      background: #eff6ff;
      border-color: #3498db;
      color: #2b77c9;
    }
    
    /* Analysis results */
    .analysis-results {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 1rem;
    }
    
    .analysis-results pre {
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .modal.hidden {
      display: none;
    }
    
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      margin: 1rem;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .help-section {
      background: #f8f9fa;
      border-left: 4px solid #2c3e50;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 6px 6px 0;
    }
    
    .help-section h4 {
      margin-bottom: 0.5rem;
      color: #2c3e50;
    }
    
    .help-section ul {
      list-style: none;
      padding-left: 0;
    }
    
    .help-section li {
      padding: 0.25rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    
    /* Collapsible sections */
    .collapsible {
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      margin: 0.5rem 0;
      overflow: hidden;
    }
    
    .collapsible-header {
      padding: 0.75rem 1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      transition: all 0.2s ease;
      border-bottom: 1px solid transparent;
      background: white;
    }
    
    .collapsible-header:hover {
      background: #f8f9fa;
      border-bottom-color: #e9ecef;
    }
    
    .collapsible-header strong {
      color: #2c3e50;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }
    
    .collapsible-toggle {
      font-size: 0.9rem;
      color: #666;
      transition: transform 0.2s ease;
      font-weight: bold;
    }
    
    .collapsible.expanded .collapsible-toggle {
      transform: rotate(180deg);
    }
    
    .collapsible-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      background: white;
    }
    
    .collapsible.expanded .collapsible-content {
      max-height: 1000px;
    }
    
    .collapsible-body {
      padding: 1rem;
      color: #555;
      font-size: 0.9rem;
      line-height: 1.5;
      border-top: 1px solid #f1f3f4;
    }

    /* Analysis parameters */
    .analysis-params {
      background: #f8f9fa;
      padding: 1rem;
      border-radius: 6px;
      margin-bottom: 1rem;
      border: 1px solid #e9ecef;
    }
    
    .analysis-params.hidden {
      display: none;
    }
    
    .param-input {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .param-input input {
      width: 120px;
      flex-shrink: 0;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      
      .split-view {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      .split-view::after {
        display: none;
      }
      
      .grid-2, .grid-3 {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .param-input {
        flex-direction: column;
        align-items: stretch;
      }
      
      .param-input input {
        width: 100%;
      }
      
      .hero .container > div {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .hero h1 {
        margin-bottom: 0;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <section class="hero">
    <div class="hero-body">
      <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
          <h1 style="margin-bottom: 0;">Structured Reasoning Analyzer</h1>
          <div style="display: flex; gap: 0.5rem;">
            <button onclick="showHelp()" class="button">
              Help (H)
            </button>
            <button onclick="quit()" class="button danger">
              Exit (Q)
            </button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <div class="container">
    <!-- Data Loading Controls -->
    <div class="card">
      <h2>Data Configuration</h2>
      <div class="grid-3">
        <div>
          <label>Model Size:</label>
          <select id="model-size">
            <option value="1.5b">1.5B Model</option>
            <option value="7b">7B Model</option>
          </select>
        </div>
        <div>
          <label>Benchmark Dataset:</label>
          <select id="benchmark">
            <option value="olympiadbench">OlympiadBench</option>
            <option value="lsat">LSAT</option>
            <option value="math500">Math500</option>
            <option value="drop">Drop</option>
          </select>
        </div>
        <div style="display: flex; align-items: end;">
          <button onclick="loadData()" class="button primary" style="width: 100%;">
            Load Data (R)
          </button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="card">
      <div class="split-view">
        <!-- Structured Reasoning -->
        <div>
          <h3>Structured Reasoning <span id="structured-id" style="font-size: 0.8rem; color: #666; font-weight: normal;"></span></h3>
          <div id="structured-content">
            <div class="loading">Initializing...</div>
          </div>
        </div>

        <!-- Unstructured Reasoning -->
        <div>
          <h3>Unstructured Reasoning</h3>
          <div id="unstructured-content">
            <div class="loading">Initializing...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Analysis Tools -->
    <div class="card">
      <h3>Analysis Tools</h3>
      <div class="grid-3">
        <button onclick="showMaxFlowAnalysis()" class="button success">
          Max-Flow Analysis (M)
        </button>
        <button onclick="showTopKAnalysis()" class="button warning">
          Top-K Analysis (K)
        </button>
        <button onclick="showTopPAnalysis()" class="button info">
          Top-P Analysis (P)
        </button>
      </div>
      <div id="analysis-params" class="analysis-params hidden">
        <!-- Dynamic parameter input area -->
      </div>
      <div id="analysis-results"></div>
    </div>

    <!-- Navigation -->
    <div class="card">
      <div class="progress-container">
        <button onclick="prevProblem()" class="button">
          Previous (←)
        </button>
        <div class="progress-bar">
          <div id="progress-fill" class="progress-bar-fill" style="width: 0%"></div>
        </div>
        <div id="progress-text" class="progress-text">0/0</div>
        <button onclick="nextProblem()" class="button">
          Next (→)
        </button>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help-modal" class="modal hidden">
    <div class="modal-content">
      <h2>Help & Documentation</h2>
      <div class="help-section">
        <h4>Keyboard Shortcuts:</h4>
        <ul>
          <li>← / → - Navigate between problems</li>
          <li>M - Run Max-Flow analysis</li>
          <li>K - Run Top-K analysis</li>
          <li>P - Run Top-P analysis</li>
          <li>R - Reload data</li>
          <li>H - Show this help</li>
          <li>Q - Exit application</li>
        </ul>
      </div>
      <div class="help-section">
        <h4>Analysis Methods:</h4>
        <p><strong>Max-Flow:</strong> Constructs sparse reasoning graphs by analyzing step-to-step attention matrices and measures the quality based on each step's contribution to the final answer.</p>
        <p><strong>Top-K:</strong> Selects the top K most attended steps at each reasoning stage.</p>
        <p><strong>Top-P:</strong> Uses nucleus sampling to select steps that cumulatively account for probability mass P.</p>
      </div>
      <button onclick="hideHelp()" class="button primary" style="margin-top: 1rem;">
        Close
      </button>
    </div>
  </div>

  <script>
    let currentState = {
      currentIndex: 0,
      structuredData: [],
      unstructuredData: [],
      modelSize: '1.5b',
      benchmark: 'olympiadbench'
    };

    // File path mapping
    const modelMap = {
      '1.5b': {
        'maxflow': 'Structured-R1-Norm',
        'grpo': 'UNS_GRPO_1_5B_4k'
      },
      '7b': {
        'maxflow': 'MAX_FLOW_7B_4k',
        'grpo': 'UNS_GRPO_7B_4k'
      }
    };

    // Initialize Pyodide
    async function initPyodide() {
      try {
        document.getElementById('structured-content').innerHTML = '<div class="loading">Initializing Python environment...</div>';
        document.getElementById('unstructured-content').innerHTML = '<div class="loading">Initializing Python environment...</div>';
        
        let pyodide = await loadPyodide();
        await pyodide.loadPackage(['numpy', 'networkx']);
        window.pyodide = pyodide;
        console.log('✅ Pyodide initialized');
        
        // Clear loading indicators
        document.getElementById('structured-content').innerHTML = '<div class="step-box">Please load data to begin analysis</div>';
        document.getElementById('unstructured-content').innerHTML = '<div class="step-box">Please load data to begin analysis</div>';
      } catch (error) {
        console.error('❌ Pyodide initialization failed:', error);
        document.getElementById('structured-content').innerHTML = `
          <div class="alert error">
            Initialization failed: ${error.message}
          </div>
        `;
        document.getElementById('unstructured-content').innerHTML = `
          <div class="alert error">
            Initialization failed: ${error.message}
          </div>
        `;
      }
    }

    // Load data
    async function loadData() {
        const modelSize = document.getElementById('model-size').value;
        const benchmark = document.getElementById('benchmark').value;
        const structuredPath = `./static/json_data/${benchmark}_results_${modelMap[modelSize].maxflow}_step_attention.json`;
        const unstructuredPath = `./static/json_data/${benchmark}_results_${modelMap[modelSize].grpo}.json`;
        
        try {
            // Show loading state
            document.getElementById('structured-content').innerHTML = '<div class="loading">Loading structured data...</div>';
            document.getElementById('unstructured-content').innerHTML = '<div class="loading">Loading unstructured data...</div>';

            // Fetch both data sources in parallel
            const [structuredResponse, unstructuredResponse] = await Promise.all([
                fetch(structuredPath),
                fetch(unstructuredPath)
            ]);

            if (!structuredResponse.ok || !unstructuredResponse.ok) {
                throw new Error('Network response was not ok');
            }

            // Parse JSON data
            const structuredJson = await structuredResponse.json();
            const unstructuredJson = await unstructuredResponse.json();

            // Check data structure and assign correctly
            if (!structuredJson.structured?.details) {
                throw new Error('Invalid structured data format: missing structured.details');
            }
            if (!unstructuredJson.unstructured?.details) {
                throw new Error('Invalid unstructured data format: missing unstructured.details');
            }

            // Update state
            currentState.structuredData = structuredJson.structured.details;
            currentState.unstructuredData = unstructuredJson.unstructured.details;
            currentState.currentIndex = 0;
            currentState.modelSize = modelSize;
            currentState.benchmark = benchmark;

            // Update display
            updateDisplay();
            console.log("✅ Data loaded successfully");
        } catch (error) {
            console.error("❌ Data loading failed:", error);
            document.getElementById('structured-content').innerHTML = `
                <div class="alert error">
                    Loading failed: ${error.message}
                </div>
            `;
            document.getElementById('unstructured-content').innerHTML = `
                <div class="alert error">
                    Loading failed: ${error.message}
                </div>
            `;
        }
    }

    // Update display
    function updateDisplay() {
      // Ensure data exists
      if (!currentState.structuredData || !currentState.unstructuredData) {
          console.error("No data available");
          return;
      }

      const problem = currentState.structuredData[currentState.currentIndex];
      if (!problem) {
          console.error("Invalid problem index");
          return;
      }

      const unstructured = findMatchingProblem(problem.problem);
      
      document.getElementById('structured-content').innerHTML = `
        <div class="step-box">
          <strong>Problem:</strong><br>${problem.problem}
        </div>
        <div class="step-box ${problem.correct ? 'correct' : 'incorrect'}">
          <strong>Predicted Answer:</strong><br>${problem.prediction}
          <div class="status-indicator ${problem.correct ? 'correct' : 'incorrect'}">
            ${problem.correct ? 'Correct' : 'Incorrect'}
          </div>
        </div>
        <div class="step-box">
          <strong>Token Usage:</strong><br>
          ${problem.tokens === 1 ? 
            '<span style="color: #e74c3c;">Out of Maximum Length</span>' : 
            problem.tokens}
        </div>
        <div id="steps">
          ${parseAndDisplaySteps(problem)}
        </div>
      `;
      
      // Function to parse reasoning steps with collapsible display
      function parseAndDisplaySteps(problem) {
        if (!problem.reasoning) return '';
        
        // Parse tags and content from reasoning text
        const pattern = /<(\w+)>(.*?)(?=<\w+>|$)/gs;
        const matches = [...problem.reasoning.matchAll(pattern)];
        
        // Match parsing results with step information - all steps are now collapsible
        return problem.step_attention_steps.map(step => {
          const matchingStep = matches.find(match => match[1] === step.step_tag);
          let content = matchingStep ? matchingStep[2].trim() : '';
          
          // If it's an ANSWER step, replace content with prediction result
          if (step.step_tag.toLowerCase() === 'answer') {
            content = problem.prediction;
          }
          
          // All steps are now collapsible
          return `
            <div class="collapsible" onclick="toggleCollapsible(this)">
              <div class="collapsible-header">
                <strong>${step.step_tag.toUpperCase()} (Step ${step.step})</strong>
                <span class="collapsible-toggle">▼</span>
              </div>
              <div class="collapsible-content">
                <div class="collapsible-body">${content || 'No content available'}</div>
              </div>
            </div>
          `;
        }).join('');
      }

      // Display unstructured content with collapsible reasoning
      if (unstructured) {
        const reasoningContent = unstructured.reasoning ? 
          `<div class="collapsible" onclick="toggleCollapsible(this)">
            <div class="collapsible-header">
              <strong>Reasoning Process</strong>
              <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content">
              <div class="collapsible-body">${unstructured.reasoning}</div>
            </div>
          </div>` :
          `<div class="step-box">
            <strong>Reasoning Process:</strong><br>No reasoning content available
          </div>`;

        document.getElementById('unstructured-content').innerHTML = `
          <div class="step-box">
            <strong>Problem:</strong><br>${unstructured.problem}
          </div>
          <div class="step-box ${unstructured.correct ? 'correct' : 'incorrect'}">
            <strong>Predicted Answer:</strong><br>${unstructured.prediction}
            <div class="status-indicator ${unstructured.correct ? 'correct' : 'incorrect'}">
              ${unstructured.correct ? 'Correct' : 'Incorrect'}
            </div>
          </div>
          <div class="step-box">
            <strong>Token Usage:</strong><br>
            ${unstructured.tokens === 1 ? 
              '<span style="color: #e74c3c;">Out of Maximum Length</span>' : 
              unstructured.tokens}
          </div>
          ${reasoningContent}
        `;
      } else {
        document.getElementById('unstructured-content').innerHTML = `
          <div class="step-box">No matching unstructured reasoning found</div>
        `;
      }
      
      // Update progress bar
      updateProgress();
    }

    // Find matching unstructured reasoning
    function findMatchingProblem(problemText) {
      return currentState.unstructuredData.find(item => item.problem === problemText);
    }

    // Toggle collapsible sections
    function toggleCollapsible(element) {
      element.classList.toggle('expanded');
    }

    // Update progress bar
    function updateProgress() {
      const total = currentState.structuredData.length;
      const current = currentState.currentIndex + 1;
      const percentage = (current / total) * 100;
      
      document.getElementById('progress-fill').style.width = `${percentage}%`;
      document.getElementById('progress-text').textContent = `${current}/${total}`;
    }

    // Analysis functions
    async function showMaxFlowAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="param-input">
          <label>Number of nodes to remove:</label>
          <input type="number" id="remove-n" value="0" min="0">
          <button onclick="runMaxFlowAnalysis()" class="button success">
            Run Analysis
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runMaxFlowAnalysis() {
        const removeN = parseInt(document.getElementById('remove-n').value);
        const problem = currentState.structuredData[currentState.currentIndex];
        
        try {
            document.getElementById('analysis-results').innerHTML = '<div class="loading">Analyzing...</div>';
            
            // Check data exists
            if (!problem.step_attention_matrix || !problem.step_attention_steps) {
                throw new Error('Missing required data: step_attention_matrix or step_attention_steps');
            }

            // Create copy of steps and add question node
            const steps = [
                {"step_tag": "question", "step": 0},
                ...problem.step_attention_steps
            ];
            
            const result = await pyodide.runPythonAsync(`
                import networkx as nx
                import numpy as np

                def select_steps_by_max_flow(step_attention_matrix, remove_n=0):
                    n_steps = len(step_attention_matrix)
                    
                    # Create directed graph
                    G = nx.DiGraph()
                    
                    # Add nodes
                    for i in range(n_steps-1):
                        G.add_node(i)
                    
                    # Add edges
                    for i in range(n_steps-1):
                        for j in range(n_steps-1):
                            if step_attention_matrix[i][j] > 0:
                                G.add_edge(i, j, capacity=step_attention_matrix[i][j])
                    
                    # Calculate node importance
                    node_importance = {}
                    source = 0
                    target = n_steps-2
                    
                    try:
                        original_max_flow = nx.maximum_flow_value(G, source, target)
                    except:
                        original_max_flow = 0
                    
                    for node in range(0, n_steps-1):
                        G_temp = G.copy()
                        G_temp.remove_node(node)
                        
                        try:
                            new_max_flow = nx.maximum_flow_value(G_temp, source, target)
                            node_importance[node] = original_max_flow - new_max_flow
                        except:
                            node_importance[node] = original_max_flow
                    
                    # Normalize
                    importance_values = list(node_importance.values())
                    max_importance = max(importance_values[1:-1]) if len(importance_values) > 2 else 1
                    
                    if max_importance != 0:
                        for node in node_importance:
                            node_importance[node] = node_importance[node] / max_importance
                    
                    sorted_nodes = sorted(node_importance.items(), key=lambda x: x[1])
                    nodes_to_remove = [node for node, _ in sorted_nodes[:remove_n]]
                    kept_nodes = [i for i in range(n_steps-1) if i not in nodes_to_remove]
                    sorted_nodes = sorted(sorted_nodes, key=lambda x: x[1], reverse=True)
                    
                    return kept_nodes, sorted_nodes

                # Run analysis
                matrix = ${JSON.stringify(problem.step_attention_matrix)}
                steps = ${JSON.stringify(steps)}
                kept_nodes, sorted_nodes = select_steps_by_max_flow(matrix, ${removeN})
                kept_steps = [steps[i]['step_tag'] for i in kept_nodes]
                importance_list = [f"{steps[node]['step_tag']}: {importance:.3f}" for node, importance in sorted_nodes]
                f"Retained nodes:\\n" + "\\n".join(kept_steps) + "\\n\\nNode importance ranking:\\n" + "\\n".join(importance_list)
            `);
            
            document.getElementById('analysis-results').innerHTML = `
                <div class="analysis-results">
                    <pre>${result}</pre>
                </div>
            `;
        } catch (error) {
            console.error("Analysis failed:", error);
            document.getElementById('analysis-results').innerHTML = `
                <div class="alert error">
                    Analysis failed: ${error.message}
                </div>
            `;
        }
    }

    async function showTopKAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="param-input">
          <label>K value:</label>
          <input type="number" id="top-k" value="2" min="1">
          <button onclick="runTopKAnalysis()" class="button warning">
            Run Analysis
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runTopKAnalysis() {
      const k = parseInt(document.getElementById('top-k').value);
      const problem = currentState.structuredData[currentState.currentIndex];
      
      try {
          document.getElementById('analysis-results').innerHTML = '<div class="loading">Analyzing...</div>';
          
          // Check data
          if (!problem.step_attention_matrix || !problem.step_attention_steps) {
              throw new Error('Missing required data');
          }

          const steps = [
              {"step_tag": "question", "step": 0},
              ...problem.step_attention_steps
          ];
          
          const result = await pyodide.runPythonAsync(`
              import numpy as np

              def select_steps(step_attention_matrix, top_k):
                  if top_k <= 0:
                      raise ValueError("top_k must be greater than 0")
                  
                  n_steps = step_attention_matrix.shape[1]
                  stack = [n_steps - 2]
                  visited = set()
                  
                  selected_steps = []
                  selected_attention = []
                  
                  while stack:
                      current_step = stack.pop()
                      
                      if current_step in visited:
                          continue
                      
                      visited.add(current_step)
                      selected_steps.append(current_step)
                      
                      if current_step == 0:
                          continue
                      
                      attention_scores = step_attention_matrix[1:current_step, current_step]
                      actual_k = min(top_k, current_step)
                      topk_indices = attention_scores.argsort()[-actual_k:][::-1]
                      
                      for idx in topk_indices:
                          if idx+1 not in visited:
                              stack.append(idx+1)
                              selected_attention.append(attention_scores[idx])
                  
                  # Sort and add question node
                  ordered_indices = np.argsort(selected_steps)
                  selected_steps = [selected_steps[i] for i in ordered_indices]
                  selected_steps.insert(0, 0)
                  
                  return selected_steps

              # Run analysis
              matrix = np.array(${JSON.stringify(problem.step_attention_matrix)})
              steps = ${JSON.stringify(steps)}
              selected = select_steps(matrix, ${k})
              selected_steps = [steps[i]['step_tag'] for i in selected]
              f"Selected steps:\\n" + "\\n".join(selected_steps)
          `);
          
          document.getElementById('analysis-results').innerHTML = `
              <div class="analysis-results">
                  <pre>${result}</pre>
              </div>
          `;
      } catch (error) {
          console.error("Analysis failed:", error);
          document.getElementById('analysis-results').innerHTML = `
              <div class="alert error">
                  Analysis failed: ${error.message}
              </div>
          `;
      }
  }

    async function showTopPAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="param-input">
          <label>P value (0-1):</label>
          <input type="number" id="top-p" value="0.9" min="0" max="1" step="0.1">
          <button onclick="runTopPAnalysis()" class="button info">
            Run Analysis
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runTopPAnalysis() {
        const p = parseFloat(document.getElementById('top-p').value);
        const problem = currentState.structuredData[currentState.currentIndex];
        
        try {
            document.getElementById('analysis-results').innerHTML = '<div class="loading">Analyzing...</div>';
            
            // Check data
            if (!problem.step_attention_matrix || !problem.step_attention_steps) {
                throw new Error('Missing required data');
            }

            const steps = [
                {"step_tag": "question", "step": 0},
                ...problem.step_attention_steps
            ];
            
            const result = await pyodide.runPythonAsync(`
                import numpy as np

                def select_steps(step_attention_matrix, top_p):
                    if top_p <= 0:
                        raise ValueError("top_p must be greater than 0")
                    
                    n_steps = step_attention_matrix.shape[1]
                    stack = [n_steps - 2]
                    visited = set()
                    
                    selected_steps = []
                    selected_attention = []
                    selected_probs = []
                    
                    while stack:
                        current_step = stack.pop()
                        
                        if current_step in visited:
                            continue
                            
                        visited.add(current_step)
                        selected_steps.append(current_step)
                        
                        if current_step == 0:
                            continue
                            
                        attention_scores = step_attention_matrix[1:current_step, current_step]
                        sorted_indices = attention_scores.argsort()[::-1]
                        sorted_scores = attention_scores[sorted_indices]
                        
                        if sorted_scores.sum() > 0:
                            normalized_scores = sorted_scores / sorted_scores.sum()
                        else:
                            normalized_scores = np.ones_like(sorted_scores) / len(sorted_scores)
                            
                        cumulative_probs = np.cumsum(normalized_scores)
                        topp_indices = sorted_indices[cumulative_probs <= top_p]
                        
                        if len(topp_indices) == 0 and len(sorted_indices) > 0:
                            topp_indices = np.array([sorted_indices[0]])
                            
                        for idx in topp_indices:
                            if idx+1 not in visited:
                                stack.append(idx+1)
                                selected_attention.append(attention_scores[idx])
                                selected_probs.append(normalized_scores[np.where(sorted_indices == idx)[0][0]])
                    
                    # Sort and add question node
                    ordered_indices = np.argsort(selected_steps)
                    selected_steps = [selected_steps[i] for i in ordered_indices]
                    selected_steps.insert(0, 0)
                    
                    return selected_steps

                # Run analysis
                matrix = np.array(${JSON.stringify(problem.step_attention_matrix)})
                steps = ${JSON.stringify(steps)}
                selected = select_steps(matrix, ${p})
                selected_steps = [steps[i]['step_tag'] for i in selected]
                f"Selected steps:\\n" + "\\n".join(selected_steps)
            `);
            
            document.getElementById('analysis-results').innerHTML = `
                <div class="analysis-results">
                    <pre>${result}</pre>
                </div>
            `;
        } catch (error) {
            console.error("Analysis failed:", error);
            document.getElementById('analysis-results').innerHTML = `
                <div class="alert error">
                    Analysis failed: ${error.message}
                </div>
            `;
        }
    }

    // Navigation functions
    function prevProblem() {
      if (currentState.currentIndex > 0) {
        currentState.currentIndex--;
        updateDisplay();
      }
    }

    function nextProblem() {
      if (currentState.currentIndex < currentState.structuredData.length - 1) {
        currentState.currentIndex++;
        updateDisplay();
      }
    }

    // Help functions
    function showHelp() {
      document.getElementById('help-modal').classList.remove('hidden');
    }

    function hideHelp() {
      document.getElementById('help-modal').classList.add('hidden');
    }

    // Exit function
    function quit() {
      if (confirm('Are you sure you want to exit?')) {
        window.close();
      }
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowLeft':
          prevProblem();
          break;
        case 'ArrowRight':
          nextProblem();
          break;
        case 'h':
        case 'H':
          showHelp();
          break;
        case 'q':
        case 'Q':
          quit();
          break;
        case 'm':
        case 'M':
          showMaxFlowAnalysis();
          break;
        case 'k':
        case 'K':
          showTopKAnalysis();
          break;
        case 'p':
        case 'P':
          showTopPAnalysis();
          break;
        case 'r':
        case 'R':
          loadData();
          break;
      }
    });

    // Initialize
    initPyodide();
  </script>
</body>
</html>