<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reasoning Analyzer</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .split-view {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      position: relative;
    }
    .split-view::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      background: #ddd;
    }
    .step-box {
      border: 1px solid #ddd;
      padding: 1rem;
      margin: 0.5rem 0;
      border-radius: 0.375rem;
      background: white;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #eee;
      border-radius: 10px;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s ease;
    }
    .command-help {
      background: #f8f9fa;
      border-left: 4px solid #4CAF50;
      padding: 1rem;
      margin: 1rem 0;
    }
    .loading {
      position: relative;
      padding: 1rem;
      text-align: center;
    }
    .loading:after {
      content: '';
      display: inline-block;
      width: 1em;
      height: 1em;
      border: 2px solid #4CAF50;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
      margin-left: 0.5rem;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="container mx-auto px-4 py-8">
    <!-- Header -->
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold">推理分析器 (双列对比版)</h1>
      <div class="flex gap-4">
        <button onclick="showHelp()" class="bg-gray-500 text-white px-4 py-2 rounded">
          帮助 (H)
        </button>
        <button onclick="quit()" class="bg-red-500 text-white px-4 py-2 rounded">
          退出 (Q)
        </button>
      </div>
    </div>

    <!-- Data Loading Controls -->
    <div class="bg-white p-4 rounded shadow mb-6">
      <h2 class="text-xl font-bold mb-4">数据加载设置</h2>
      <div class="grid grid-cols-2 gap-4 mb-4">
        <div>
          <label class="block mb-2">模型大小:</label>
          <select id="model-size" class="w-full border p-2 rounded">
            <option value="1.5b">1.5B Model</option>
            <option value="7b">7B Model</option>
          </select>
        </div>
        <div>
          <label class="block mb-2">基准测试集:</label>
          <select id="benchmark" class="w-full border p-2 rounded">
            <option value="olympiadbench">OlympiadBench</option>
            <option value="lsat">LSAT</option>
            <option value="math500">Math500</option>
            <option value="drop">Drop</option>
          </select>
        </div>
      </div>
      <div class="flex justify-end">
        <button onclick="loadData()" class="bg-blue-500 text-white px-6 py-2 rounded">
          加载数据 (R)
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="split-view bg-white p-4 rounded shadow mb-6">
      <!-- Structured Reasoning -->
      <div class="pr-4">
        <h2 class="text-xl font-bold mb-4">结构化推理 <span id="structured-id" class="text-sm text-gray-500"></span></h2>
        <div id="structured-content">
          <div class="loading">初始化中...</div>
        </div>
      </div>

      <!-- Unstructured Reasoning -->
      <div class="pl-4">
        <h2 class="text-xl font-bold mb-4">非结构化推理</h2>
        <div id="unstructured-content">
          <div class="loading">初始化中...</div>
        </div>
      </div>
    </div>

    <!-- Analysis Tools -->
    <div class="bg-white p-4 rounded shadow mb-6">
      <h3 class="text-lg font-bold mb-4">分析工具</h3>
      <div class="grid grid-cols-3 gap-4 mb-4">
        <div>
          <button onclick="showMaxFlowAnalysis()" class="w-full bg-green-500 text-white px-4 py-2 rounded">
            最大流分析 (M)
          </button>
        </div>
        <div>
          <button onclick="showTopKAnalysis()" class="w-full bg-yellow-500 text-white px-4 py-2 rounded">
            Top-K分析 (K)
          </button>
        </div>
        <div>
          <button onclick="showTopPAnalysis()" class="w-full bg-purple-500 text-white px-4 py-2 rounded">
            Top-P分析 (P)
          </button>
        </div>
      </div>
      <div id="analysis-params" class="hidden mb-4">
        <!-- 动态参数输入区域 -->
      </div>
      <div id="analysis-results" class="mt-4"></div>
    </div>

    <!-- Navigation -->
    <div class="bg-white p-4 rounded shadow">
      <div class="flex justify-between items-center">
        <button onclick="prevProblem()" class="bg-gray-500 text-white px-4 py-2 rounded">
          上一题 (←)
        </button>
        <div id="progress" class="flex-1 mx-4">
          <div class="progress-bar">
            <div id="progress-fill" class="progress-bar-fill" style="width: 0%"></div>
          </div>
          <div class="text-center mt-2" id="progress-text">0/0</div>
        </div>
        <button onclick="nextProblem()" class="bg-gray-500 text-white px-4 py-2 rounded">
          下一题 (→)
        </button>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center">
      <div class="bg-white p-6 rounded-lg max-w-2xl w-full mx-4">
        <h2 class="text-2xl font-bold mb-4">帮助信息</h2>
        <div class="command-help">
          <h3 class="font-bold mb-2">🎮 控制命令:</h3>
          <ul class="space-y-2">
            <li>← / → - 上一题/下一题</li>
            <li>M - 最大流分析</li>
            <li>K - Top-K分析</li>
            <li>P - Top-P分析</li>
            <li>R - 重新加载数据</li>
            <li>H - 显示帮助</li>
            <li>Q - 退出程序</li>
          </ul>
        </div>
        <button onclick="hideHelp()" class="mt-4 bg-blue-500 text-white px-4 py-2 rounded">
          关闭
        </button>
      </div>
    </div>
  </div>

  <script>
    let currentState = {
      currentIndex: 0,
      structuredData: [],
      unstructuredData: [],
      modelSize: '1.5b',
      benchmark: 'olympiadbench'
    };

    // 文件路径映射
    const modelMap = {
      '1.5b': {
        'maxflow': 'Structured-R1-Norm',
        'grpo': 'UNS_GRPO_1_5B_4k'
      },
      '7b': {
        'maxflow': 'MAX_FLOW_7B_4k',
        'grpo': 'UNS_GRPO_7B_4k'
      }
    };

    // 初始化 Pyodide
    async function initPyodide() {
      try {
        document.getElementById('structured-content').innerHTML = '<div class="loading">正在初始化 Python 环境...</div>';
        document.getElementById('unstructured-content').innerHTML = '<div class="loading">正在初始化 Python 环境...</div>';
        
        let pyodide = await loadPyodide();
        await pyodide.loadPackage(['numpy', 'networkx']);
        window.pyodide = pyodide;
        console.log('✅ Pyodide initialized');
        
        
        // 清除加载提示
        document.getElementById('structured-content').innerHTML = '<div class="step-box">请加载数据开始分析</div>';
        document.getElementById('unstructured-content').innerHTML = '<div class="step-box">请加载数据开始分析</div>';
      } catch (error) {
        console.error('❌ Pyodide initialization failed:', error);
        document.getElementById('structured-content').innerHTML = `
          <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
            初始化失败: ${error.message}
          </div>
        `;
        document.getElementById('unstructured-content').innerHTML = `
          <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
            初始化失败: ${error.message}
          </div>
        `;
      }
    }


    // 加载数据
    // 目前加载数据存在问题
    async function loadData() {
        const modelSize = document.getElementById('model-size').value;
        const benchmark = document.getElementById('benchmark').value;
        const structuredPath = `./static/json_data/${benchmark}_results_${modelMap[modelSize].maxflow}_step_attention.json`;
        const unstructuredPath = `./static/json_data/${benchmark}_results_${modelMap[modelSize].grpo}.json`;
        
        try {
            // 显示加载状态
            document.getElementById('structured-content').innerHTML = '<div class="loading">加载结构化数据中...</div>';
            document.getElementById('unstructured-content').innerHTML = '<div class="loading">加载非结构化数据中...</div>';

            // 并行获取两个数据源
            const [structuredResponse, unstructuredResponse] = await Promise.all([
                fetch(structuredPath),
                fetch(unstructuredPath)
            ]);

            if (!structuredResponse.ok || !unstructuredResponse.ok) {
                throw new Error('Network response was not ok');
            }

            // 解析 JSON 数据
            const structuredJson = await structuredResponse.json();
            const unstructuredJson = await unstructuredResponse.json();

            // 检查数据结构并正确赋值
            if (!structuredJson.structured?.details) {
                throw new Error('Invalid structured data format: missing structured.details');
            }
            if (!unstructuredJson.unstructured?.details) {
                throw new Error('Invalid unstructured data format: missing unstructured.details');
            }

            // 更新状态
            currentState.structuredData = structuredJson.structured.details;
            currentState.unstructuredData = unstructuredJson.unstructured.details;
            currentState.currentIndex = 0;
            currentState.modelSize = modelSize;
            currentState.benchmark = benchmark;

            // 更新显示
            updateDisplay();
            console.log("✅ 数据加载成功");
        } catch (error) {
            console.error("❌ 数据加载失败:", error);
            document.getElementById('structured-content').innerHTML = `
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    加载失败: ${error.message}
                </div>
            `;
            document.getElementById('unstructured-content').innerHTML = `
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    加载失败: ${error.message}
                </div>
            `;
        }
    }
    // 更新显示
    function updateDisplay() {
      // 确保数据存在
      if (!currentState.structuredData || !currentState.unstructuredData) {
          console.error("No data available");
          return;
      }

      const problem = currentState.structuredData[currentState.currentIndex];
      if (!problem) {
          console.error("Invalid problem index");
          return;
      }

      const unstructured = findMatchingProblem(problem.problem);
      
      document.getElementById('structured-content').innerHTML = `
        <div id="problem" class="step-box">
          <strong>问题:</strong><br>${problem.problem}
        </div>
        <div id="prediction" class="step-box ${problem.correct ? 'bg-green-100' : 'bg-red-100'}">
          <strong>预测答案:</strong><br>${problem.prediction}
          <div class="mt-2 ${problem.correct ? 'text-green-600' : 'text-red-600'}">
            ${problem.correct ? '✓ 正确' : '✗ 错误'}
          </div>
        </div>
        <div id="token-usage" class="step-box">
          <strong>Token 使用量:</strong><br>
          ${problem.tokens === 1 ? 
            '<span class="text-red-600">Out of Maximum length</span>' : 
            problem.tokens}
        </div>
        <div id="steps" class="space-y-2">
          ${parseAndDisplaySteps(problem)}
        </div>
      `;
      
      // 添加解析步骤的函数
      function parseAndDisplaySteps(problem) {
        if (!problem.reasoning) return '';
        
        // 解析推理文本中的标签和内容
        const pattern = /<(\w+)>(.*?)(?=<\w+>|$)/gs;
        const matches = [...problem.reasoning.matchAll(pattern)];
        
        // 将解析结果与步骤信息对应
        return problem.step_attention_steps.map(step => {
          const matchingStep = matches.find(match => match[1] === step.step_tag);
          let content = matchingStep ? matchingStep[2].trim() : '';
          
          // 如果是 ANSWER 步骤，使用预测结果替换内容
          if (step.step_tag.toLowerCase() === 'answer') {
            content = problem.prediction;
          }
          
          return `
            <div class="step-box">
              <strong>${step.step_tag.toUpperCase()}</strong> (Step ${step.step})
              ${content ? `<div class="mt-2 text-gray-600">${content}</div>` : ''}
            </div>
          `;
        }).join('');
      }

            
      // 在非结构化内容显示中也做相同修改:
      if (unstructured) {
        document.getElementById('unstructured-content').innerHTML = `
          <div class="step-box">
            <strong>问题:</strong><br>${unstructured.problem}
          </div>
          <div class="step-box ${unstructured.correct ? 'bg-green-100' : 'bg-red-100'}">
            <strong>预测答案:</strong><br>${unstructured.prediction}
            <div class="mt-2 ${unstructured.correct ? 'text-green-600' : 'text-red-600'}">
              ${unstructured.correct ? '✓ 正确' : '✗ 错误'}
            </div>
          </div>
          <div class="step-box">
            <strong>Token 使用量:</strong><br>
            ${unstructured.tokens === 1 ? 
              '<span class="text-red-600">Out of Maximum length</span>' : 
              unstructured.tokens}
          </div>
          <div class="step-box">
            <strong>推理过程:</strong><br>${unstructured.reasoning}
          </div>
        `;
      } else {
        document.getElementById('unstructured-content').innerHTML = `
          <div class="step-box">未找到匹配的非结构化推理</div>
        `;
      }
      
      // 更新进度条
      updateProgress();
    }

    // 查找匹配的非结构化推理
    function findMatchingProblem(problemText) {
      return currentState.unstructuredData.find(item => item.problem === problemText);
    }

    // 更新进度条
    function updateProgress() {
      const total = currentState.structuredData.length;
      const current = currentState.currentIndex + 1;
      const percentage = (current / total) * 100;
      
      document.getElementById('progress-fill').style.width = `${percentage}%`;
      document.getElementById('progress-text').textContent = `${current}/${total}`;
    }

    // 分析函数
    async function showMaxFlowAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="bg-gray-100 p-4 rounded">
          <label class="block mb-2">要移除的节点数量:</label>
          <input type="number" id="remove-n" value="0" min="0" class="border p-2 rounded w-32">
          <button onclick="runMaxFlowAnalysis()" class="ml-4 bg-green-500 text-white px-4 py-2 rounded">
            运行分析
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runMaxFlowAnalysis() {
        const removeN = parseInt(document.getElementById('remove-n').value);
        const problem = currentState.structuredData[currentState.currentIndex];
        
        try {
            document.getElementById('analysis-results').innerHTML = '<div class="loading">正在分析...</div>';
            
            // 确保数据存在
            if (!problem.step_attention_matrix || !problem.step_attention_steps) {
                throw new Error('缺少必要的数据：step_attention_matrix 或 step_attention_steps');
            }

            // 创建steps的副本并添加question节点
            const steps = [
                {"step_tag": "question", "step": 0},
                ...problem.step_attention_steps
            ];
            
            const result = await pyodide.runPythonAsync(`
                import networkx as nx
                import numpy as np

                def select_steps_by_max_flow(step_attention_matrix, remove_n=0):
                    n_steps = len(step_attention_matrix)
                    
                    # 创建有向图
                    G = nx.DiGraph()
                    
                    # 添加节点
                    for i in range(n_steps-1):
                        G.add_node(i)
                    
                    # 添加边
                    for i in range(n_steps-1):
                        for j in range(n_steps-1):
                            if step_attention_matrix[i][j] > 0:
                                G.add_edge(i, j, capacity=step_attention_matrix[i][j])
                    
                    # 计算节点重要性
                    node_importance = {}
                    source = 0
                    target = n_steps-2
                    
                    try:
                        original_max_flow = nx.maximum_flow_value(G, source, target)
                    except:
                        original_max_flow = 0
                    
                    for node in range(0, n_steps-1):
                        G_temp = G.copy()
                        G_temp.remove_node(node)
                        
                        try:
                            new_max_flow = nx.maximum_flow_value(G_temp, source, target)
                            node_importance[node] = original_max_flow - new_max_flow
                        except:
                            node_importance[node] = original_max_flow
                    
                    # 归一化
                    importance_values = list(node_importance.values())
                    max_importance = max(importance_values[1:-1]) if len(importance_values) > 2 else 1
                    
                    if max_importance != 0:
                        for node in node_importance:
                            node_importance[node] = node_importance[node] / max_importance
                    
                    sorted_nodes = sorted(node_importance.items(), key=lambda x: x[1])
                    nodes_to_remove = [node for node, _ in sorted_nodes[:remove_n]]
                    kept_nodes = [i for i in range(n_steps-1) if i not in nodes_to_remove]
                    sorted_nodes = sorted(sorted_nodes, key=lambda x: x[1], reverse=True)
                    
                    return kept_nodes, sorted_nodes

                # 运行分析
                matrix = ${JSON.stringify(problem.step_attention_matrix)}
                steps = ${JSON.stringify(steps)}
                kept_nodes, sorted_nodes = select_steps_by_max_flow(matrix, ${removeN})
                kept_steps = [steps[i]['step_tag'] for i in kept_nodes]
                importance_list = [f"{steps[node]['step_tag']}: {importance:.3f}" for node, importance in sorted_nodes]
                f"保留的节点:\\n" + "\\n".join(kept_steps) + "\\n\\n节点重要性排序:\\n" + "\\n".join(importance_list)
            `);
            
            document.getElementById('analysis-results').innerHTML = `
                <div class="bg-gray-100 p-4 rounded">
                    <pre>${result}</pre>
                </div>
            `;
        } catch (error) {
            console.error("分析失败:", error);
            document.getElementById('analysis-results').innerHTML = `
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    分析失败: ${error.message}
                </div>
            `;
        }
    }

    async function showTopKAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="bg-gray-100 p-4 rounded">
          <label class="block mb-2">K值:</label>
          <input type="number" id="top-k" value="2" min="1" class="border p-2 rounded w-32">
          <button onclick="runTopKAnalysis()" class="ml-4 bg-yellow-500 text-white px-4 py-2 rounded">
            运行分析
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runTopKAnalysis() {
      const k = parseInt(document.getElementById('top-k').value);
      const problem = currentState.structuredData[currentState.currentIndex];
      
      try {
          document.getElementById('analysis-results').innerHTML = '<div class="loading">正在分析...</div>';
          
          // 检查数据
          if (!problem.step_attention_matrix || !problem.step_attention_steps) {
              throw new Error('缺少必要的数据');
          }

          const steps = [
              {"step_tag": "question", "step": 0},
              ...problem.step_attention_steps
          ];
          
          const result = await pyodide.runPythonAsync(`
              import numpy as np

              def select_steps(step_attention_matrix, top_k):
                  if top_k <= 0:
                      raise ValueError("top_k必须大于0")
                  
                  n_steps = step_attention_matrix.shape[1]
                  stack = [n_steps - 2]
                  visited = set()
                  
                  selected_steps = []
                  selected_attention = []
                  
                  while stack:
                      current_step = stack.pop()
                      
                      if current_step in visited:
                          continue
                      
                      visited.add(current_step)
                      selected_steps.append(current_step)
                      
                      if current_step == 0:
                          continue
                      
                      attention_scores = step_attention_matrix[1:current_step, current_step]
                      actual_k = min(top_k, current_step)
                      topk_indices = attention_scores.argsort()[-actual_k:][::-1]
                      
                      for idx in topk_indices:
                          if idx+1 not in visited:
                              stack.append(idx+1)
                              selected_attention.append(attention_scores[idx])
                  
                  # 排序并添加问题节点
                  ordered_indices = np.argsort(selected_steps)
                  selected_steps = [selected_steps[i] for i in ordered_indices]
                  selected_steps.insert(0, 0)
                  
                  return selected_steps

              # 运行分析
              matrix = np.array(${JSON.stringify(problem.step_attention_matrix)})
              steps = ${JSON.stringify(steps)}
              selected = select_steps(matrix, ${k})
              selected_steps = [steps[i]['step_tag'] for i in selected]
              f"选中的步骤:\\n" + "\\n".join(selected_steps)
          `);
          
          document.getElementById('analysis-results').innerHTML = `
              <div class="bg-gray-100 p-4 rounded">
                  <pre>${result}</pre>
              </div>
          `;
      } catch (error) {
          console.error("分析失败:", error);
          document.getElementById('analysis-results').innerHTML = `
              <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                  分析失败: ${error.message}
              </div>
          `;
      }
  }


    async function showTopPAnalysis() {
      document.getElementById('analysis-params').innerHTML = `
        <div class="bg-gray-100 p-4 rounded">
          <label class="block mb-2">P值 (0-1):</label>
          <input type="number" id="top-p" value="0.9" min="0" max="1" step="0.1" class="border p-2 rounded w-32">
          <button onclick="runTopPAnalysis()" class="ml-4 bg-purple-500 text-white px-4 py-2 rounded">
            运行分析
          </button>
        </div>
      `;
      document.getElementById('analysis-params').classList.remove('hidden');
    }

    async function runTopPAnalysis() {
        const p = parseFloat(document.getElementById('top-p').value);
        const problem = currentState.structuredData[currentState.currentIndex];
        
        try {
            document.getElementById('analysis-results').innerHTML = '<div class="loading">正在分析...</div>';
            
            // 检查数据
            if (!problem.step_attention_matrix || !problem.step_attention_steps) {
                throw new Error('缺少必要的数据');
            }

            const steps = [
                {"step_tag": "question", "step": 0},
                ...problem.step_attention_steps
            ];
            
            const result = await pyodide.runPythonAsync(`
                import numpy as np

                def select_steps(step_attention_matrix, top_p):
                    if top_p <= 0:
                        raise ValueError("top_p必须大于0")
                    
                    n_steps = step_attention_matrix.shape[1]
                    stack = [n_steps - 2]
                    visited = set()
                    
                    selected_steps = []
                    selected_attention = []
                    selected_probs = []
                    
                    while stack:
                        current_step = stack.pop()
                        
                        if current_step in visited:
                            continue
                            
                        visited.add(current_step)
                        selected_steps.append(current_step)
                        
                        if current_step == 0:
                            continue
                            
                        attention_scores = step_attention_matrix[1:current_step, current_step]
                        sorted_indices = attention_scores.argsort()[::-1]
                        sorted_scores = attention_scores[sorted_indices]
                        
                        if sorted_scores.sum() > 0:
                            normalized_scores = sorted_scores / sorted_scores.sum()
                        else:
                            normalized_scores = np.ones_like(sorted_scores) / len(sorted_scores)
                            
                        cumulative_probs = np.cumsum(normalized_scores)
                        topp_indices = sorted_indices[cumulative_probs <= top_p]
                        
                        if len(topp_indices) == 0 and len(sorted_indices) > 0:
                            topp_indices = np.array([sorted_indices[0]])
                            
                        for idx in topp_indices:
                            if idx+1 not in visited:
                                stack.append(idx+1)
                                selected_attention.append(attention_scores[idx])
                                selected_probs.append(normalized_scores[np.where(sorted_indices == idx)[0][0]])
                    
                    # 排序并添加问题节点
                    ordered_indices = np.argsort(selected_steps)
                    selected_steps = [selected_steps[i] for i in ordered_indices]
                    selected_steps.insert(0, 0)
                    
                    return selected_steps

                # 运行分析
                matrix = np.array(${JSON.stringify(problem.step_attention_matrix)})
                steps = ${JSON.stringify(steps)}
                selected = select_steps(matrix, ${p})
                selected_steps = [steps[i]['step_tag'] for i in selected]
                f"选中的步骤:\\n" + "\\n".join(selected_steps)
            `);
            
            document.getElementById('analysis-results').innerHTML = `
                <div class="bg-gray-100 p-4 rounded">
                    <pre>${result}</pre>
                </div>
            `;
        } catch (error) {
            console.error("分析失败:", error);
            document.getElementById('analysis-results').innerHTML = `
                <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    分析失败: ${error.message}
                </div>
            `;
        }
    }


    // 导航函数
    function prevProblem() {
      if (currentState.currentIndex > 0) {
        currentState.currentIndex--;
        updateDisplay();
      }
    }

    function nextProblem() {
      if (currentState.currentIndex < currentState.structuredData.length - 1) {
        currentState.currentIndex++;
        updateDisplay();
      }
    }

    // 帮助相关函数
    function showHelp() {
      document.getElementById('help-modal').classList.remove('hidden');
    }

    function hideHelp() {
      document.getElementById('help-modal').classList.add('hidden');
    }

    // 退出函数
    function quit() {
      if (confirm('确定要退出吗？')) {
        window.close();
      }
    }

    // 键盘快捷键
    document.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowLeft':
          prevProblem();
          break;
        case 'ArrowRight':
          nextProblem();
          break;
        case 'h':
        case 'H':
          showHelp();
          break;
        case 'q':
        case 'Q':
          quit();
          break;
        case 'm':
        case 'M':
          showMaxFlowAnalysis();
          break;
        case 'k':
        case 'K':
          showTopKAnalysis();
          break;
        case 'p':
        case 'P':
          showTopPAnalysis();
          break;
        case 'r':
        case 'R':
          loadData();
          break;
      }
    });

    // 初始化
    initPyodide();
  </script>
</body>
</html>